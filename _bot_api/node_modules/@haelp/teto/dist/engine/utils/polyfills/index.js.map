{"version":3,"sources":["../../../../src/engine/utils/polyfills/index.ts"],"sourcesContent":["export namespace polyfills {\n  export class Map<K, V> {\n    private _entries: Array<[K, V]> = [];\n\n    constructor(iterable?: Iterable<[K, V]>) {\n      if (iterable) {\n        for (const [key, value] of iterable) {\n          this.set(key, value);\n        }\n      }\n    }\n\n    get size(): number {\n      return this._entries.length;\n    }\n\n    set = (key: K, value: V): this => {\n      const index = this._entries.findIndex(([k]) => k === key);\n      if (index !== -1) {\n        this._entries[index][1] = value;\n      } else {\n        this._entries.push([key, value]);\n      }\n      return this;\n    };\n\n    get = (key: K): V | undefined => {\n      const entry = this._entries.find(([k]) => k === key);\n      return entry ? entry[1] : undefined;\n    };\n\n    has = (key: K): boolean => {\n      return this._entries.some(([k]) => k === key);\n    };\n\n    delete = (key: K): boolean => {\n      const index = this._entries.findIndex(([k]) => k === key);\n      if (index !== -1) {\n        this._entries.splice(index, 1);\n        return true;\n      }\n      return false;\n    };\n\n    clear = (): void => {\n      this._entries = [];\n    };\n\n    forEach = (\n      callback: (value: V, key: K, map: Map<K, V>) => void,\n      thisArg?: any\n    ): void => {\n      // Use a shallow copy to prevent issues if the map is modified during iteration\n      const entriesCopy = this._entries.slice();\n      for (const [key, value] of entriesCopy) {\n        callback.call(thisArg, value, key, this);\n      }\n    };\n\n    *entries(): IterableIterator<[K, V]> {\n      for (const entry of this._entries) {\n        yield entry;\n      }\n    }\n\n    *keys(): IterableIterator<K> {\n      for (const [key] of this._entries) {\n        yield key;\n      }\n    }\n\n    *values(): IterableIterator<V> {\n      for (const [, value] of this._entries) {\n        yield value;\n      }\n    }\n\n    [Symbol.iterator] = function* (this: Map<K, V>) {\n      yield* this.entries();\n    };\n  }\n}\n"],"names":["polyfills","Map","_entries","iterable","key","value","set","size","length","index","findIndex","k","push","get","entry","find","undefined","has","some","delete","splice","clear","forEach","callback","thisArg","entriesCopy","slice","call","entries","keys","values","Symbol","iterator"],"mappings":";;;;;;;;;;UAAiBA;IACR,MAAMC;QACHC,WAA0B,EAAE,CAAC;QAErC,YAAYC,QAA2B,CAAE;YACvC,IAAIA,UAAU;gBACZ,KAAK,MAAM,CAACC,KAAKC,MAAM,IAAIF,SAAU;oBACnC,IAAI,CAACG,GAAG,CAACF,KAAKC;gBAChB;YACF;QACF;QAEA,IAAIE,OAAe;YACjB,OAAO,IAAI,CAACL,QAAQ,CAACM,MAAM;QAC7B;QAEAF,MAAM,CAACF,KAAQC;YACb,MAAMI,QAAQ,IAAI,CAACP,QAAQ,CAACQ,SAAS,CAAC,CAAC,CAACC,EAAE,GAAKA,MAAMP;YACrD,IAAIK,UAAU,CAAC,GAAG;gBAChB,IAAI,CAACP,QAAQ,CAACO,MAAM,CAAC,EAAE,GAAGJ;YAC5B,OAAO;gBACL,IAAI,CAACH,QAAQ,CAACU,IAAI,CAAC;oBAACR;oBAAKC;iBAAM;YACjC;YACA,OAAO,IAAI;QACb,EAAE;QAEFQ,MAAM,CAACT;YACL,MAAMU,QAAQ,IAAI,CAACZ,QAAQ,CAACa,IAAI,CAAC,CAAC,CAACJ,EAAE,GAAKA,MAAMP;YAChD,OAAOU,QAAQA,KAAK,CAAC,EAAE,GAAGE;QAC5B,EAAE;QAEFC,MAAM,CAACb;YACL,OAAO,IAAI,CAACF,QAAQ,CAACgB,IAAI,CAAC,CAAC,CAACP,EAAE,GAAKA,MAAMP;QAC3C,EAAE;QAEFe,SAAS,CAACf;YACR,MAAMK,QAAQ,IAAI,CAACP,QAAQ,CAACQ,SAAS,CAAC,CAAC,CAACC,EAAE,GAAKA,MAAMP;YACrD,IAAIK,UAAU,CAAC,GAAG;gBAChB,IAAI,CAACP,QAAQ,CAACkB,MAAM,CAACX,OAAO;gBAC5B,OAAO;YACT;YACA,OAAO;QACT,EAAE;QAEFY,QAAQ;YACN,IAAI,CAACnB,QAAQ,GAAG,EAAE;QACpB,EAAE;QAEFoB,UAAU,CACRC,UACAC;YAEA,+EAA+E;YAC/E,MAAMC,cAAc,IAAI,CAACvB,QAAQ,CAACwB,KAAK;YACvC,KAAK,MAAM,CAACtB,KAAKC,MAAM,IAAIoB,YAAa;gBACtCF,SAASI,IAAI,CAACH,SAASnB,OAAOD,KAAK,IAAI;YACzC;QACF,EAAE;QAEF,CAACwB,UAAoC;YACnC,KAAK,MAAMd,SAAS,IAAI,CAACZ,QAAQ,CAAE;gBACjC,MAAMY;YACR;QACF;QAEA,CAACe,OAA4B;YAC3B,KAAK,MAAM,CAACzB,IAAI,IAAI,IAAI,CAACF,QAAQ,CAAE;gBACjC,MAAME;YACR;QACF;QAEA,CAAC0B,SAA8B;YAC7B,KAAK,MAAM,GAAGzB,MAAM,IAAI,IAAI,CAACH,QAAQ,CAAE;gBACrC,MAAMG;YACR;QACF;QAEA,CAAC0B,OAAOC,QAAQ,CAAC,GAAG;YAClB,OAAO,IAAI,CAACJ,OAAO;QACrB,EAAE;IACJ;cA/Ea3B,MAAAA;AAgFf,GAjFiBD,cAAAA"}