import { deepCopy } from "../index.mjs";
import { legal, performKick } from "../kicks/index.mjs";
import { tetrominoes } from "./data.mjs";
export class Tetromino {
    #rotation;
    symbol;
    states;
    location;
    locking;
    lockResets;
    rotResets;
    safeLock;
    highestY;
    fallingRotations;
    totalRotations;
    irs;
    ihs;
    aox;
    aoy;
    keys;
    constructor(options){
        this.rotation = options.initialRotation;
        this.symbol = options.symbol;
        const tetromino = tetrominoes[this.symbol.toLowerCase()];
        this.states = tetromino.matrix.data;
        this.location = [
            Math.floor(options.boardWidth / 2 - tetromino.matrix.w / 2),
            options.boardHeight + 2.04
        ];
        // other stuff
        this.locking = 0;
        this.lockResets = 0;
        this.rotResets = 0;
        this.safeLock = options.from?.safeLock ?? 0;
        this.highestY = options.boardHeight + 2;
        this.fallingRotations = 0;
        this.totalRotations = 0;
        this.irs = options.from?.irs ?? 0;
        this.ihs = options.from?.ihs ?? false;
        this.aox = 0;
        this.aoy = 0;
        this.keys = 0;
    }
    get blocks() {
        return this.states[Math.min(this.rotation, this.states.length)];
    }
    get absoluteBlocks() {
        return this.blocks.map((block)=>[
                block[0] + this.location[0],
                -block[1] + this.y
            ]);
    }
    absoluteAt({ x = this.location[0], y = this.location[1], rotation = this.rotation }) {
        const currentState = [
            this.location[0],
            this.location[1],
            this.rotation
        ];
        this.location = [
            x,
            y
        ];
        this.rotation = rotation;
        const res = this.absoluteBlocks;
        this.location = [
            currentState[0],
            currentState[1]
        ];
        this.rotation = currentState[2];
        return res;
    }
    get rotation() {
        return this.#rotation % 4;
    }
    set rotation(value) {
        this.#rotation = value % 4;
    }
    get x() {
        return this.location[0];
    }
    set x(value) {
        this.location[0] = value;
    }
    get y() {
        return Math.floor(this.location[1]);
    }
    set y(value) {
        this.location[1] = value;
    }
    isStupidSpinPosition(board) {
        return !legal(this.blocks.map((block)=>[
                block[0] + this.location[0],
                -block[1] + this.y - 1
            ]), board);
    }
    isAllSpinPosition(board) {
        return !legal(this.blocks.map((block)=>[
                block[0] + this.location[0] - 1,
                -block[1] + this.y
            ]), board) && !legal(this.blocks.map((block)=>[
                block[0] + this.location[0] + 1,
                -block[1] + this.y
            ]), board) && !legal(this.blocks.map((block)=>[
                block[0] + this.location[0],
                -block[1] + this.y + 1
            ]), board) && !legal(this.blocks.map((block)=>[
                block[0] + this.location[0],
                -block[1] + this.y - 1
            ]), board);
    }
    rotate(board, kickTable, amt, maxMovement) {
        const rotatedBlocks = this.states[(this.rotation + amt) % 4];
        const kickRes = performKick(kickTable, this.symbol, this.location, [
            this.aox,
            this.aoy
        ], maxMovement, rotatedBlocks, this.rotation, (this.rotation + amt) % 4, board);
        if (typeof kickRes === "object") {
            this.location = [
                ...kickRes.newLocation
            ];
        }
        if (kickRes) {
            this.rotation = this.rotation + amt;
            return kickRes;
        }
        return false;
    }
    moveRight(board) {
        if (legal(this.blocks.map((block)=>[
                block[0] + this.location[0] + 1,
                -block[1] + this.y
            ]), board)) {
            this.location[0]++;
            return true;
        }
        return false;
    }
    moveLeft(board) {
        if (legal(this.blocks.map((block)=>[
                block[0] + this.location[0] - 1,
                -block[1] + this.y
            ]), board)) {
            this.location[0]--;
            return true;
        }
        return false;
    }
    dasRight(board) {
        if (this.moveRight(board)) {
            while(this.moveRight(board)){}
            return true;
        }
        return false;
    }
    dasLeft(board) {
        if (this.moveLeft(board)) {
            while(this.moveLeft(board)){}
            return true;
        }
        return false;
    }
    softDrop(board) {
        const start = this.location[1];
        while(legal(this.blocks.map((block)=>[
                block[0] + this.location[0],
                -block[1] + this.y - 1
            ]), board)){
            this.location[1]--;
        }
        return start !== this.location[1];
    }
    snapshot() {
        return {
            aox: this.aox,
            aoy: this.aoy,
            fallingRotations: this.fallingRotations,
            highestY: this.highestY,
            ihs: this.ihs,
            irs: this.irs,
            keys: this.keys,
            rotation: this.rotation,
            location: deepCopy(this.location),
            locking: this.locking,
            lockResets: this.lockResets,
            rotResets: this.rotResets,
            safeLock: this.safeLock,
            symbol: this.symbol,
            totalRotations: this.totalRotations
        };
    }
}
export * from "./data.mjs";
export * from "./types.mjs";

//# sourceMappingURL=index.js.map