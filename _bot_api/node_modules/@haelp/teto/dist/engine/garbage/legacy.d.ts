import { type GarbageQueueInitializeParams, type IncomingGarbage, type GarbageQueueSnapshot, type OutgoingGarbage } from ".";
import { RNG } from "../utils";
export declare class LegacyGarbageQueue {
    #private;
    options: GarbageQueueInitializeParams;
    queue: IncomingGarbage[];
    lastTankTime: number;
    lastColumn: number | null;
    rng: RNG;
    sent: number;
    constructor(options: GarbageQueueInitializeParams);
    snapshot(): GarbageQueueSnapshot;
    fromSnapshot(snapshot: GarbageQueueSnapshot): void;
    rngex(): number;
    get size(): number;
    receive(...args: IncomingGarbage[]): void;
    confirm(cid: number, gameid: number, frame: number): boolean;
    cancel(amount: number, pieceCount: number, legacy?: {
        openerPhase?: boolean;
    }): readonly [number, IncomingGarbage[]];
    /**
     * This function does NOT take into account messiness on timeout.
     * The first garbage hole will be correct,
     * but subsequent holes depend on whether or not garbage is cancelled.
     */
    predict(): never[] | OutgoingGarbage[];
    get nextColumn(): number;
    tank(frame: number, cap: number, hard: boolean): {
        bombs: boolean;
        id: number;
        column: number;
        frame: number;
        amount: number;
        size: number;
    }[];
    round(amount: number): number;
}
//# sourceMappingURL=legacy.d.ts.map