import type { Game } from "../types/game";
import { EventEmitter } from "../utils/events";
import { Board, type BoardInitializeParams, ConnectedBoard } from "./board";
import { GarbageQueue, type GarbageQueueInitializeParams, type IncomingGarbage, LegacyGarbageQueue, type OutgoingGarbage } from "./garbage";
import { IGEHandler, type MultiplayerOptions } from "./multiplayer";
import { Queue, type QueueInitializeParams } from "./queue";
import { Mino } from "./queue/types";
import type { EngineSnapshot, Events, IncreasableValue, LockRes, SpinType } from "./types";
import { IncreaseTracker } from "./utils";
import { garbageData } from "./utils/damageCalc";
import { type KickTable } from "./utils/kicks";
import { type KickTableName, kicks } from "./utils/kicks/data";
import { Tetromino } from "./utils/tetromino";
export interface GameOptions {
    spinBonuses: Game.SpinBonuses;
    comboTable: keyof (typeof garbageData)["comboTable"] | "multiplier";
    garbageTargetBonus: "none" | "normal" | string;
    clutch: boolean;
    garbageBlocking: "combo blocking" | "limited blocking" | "none";
}
export type PCOptions = false | {
    garbage: number;
    b2b: number;
};
export interface B2BOptions {
    chaining: boolean;
    charging: false | {
        at: number;
        base: number;
    };
}
export interface MiscellaneousOptions {
    movement: {
        infinite: boolean;
        lockResets: number;
        lockTime: number;
        may20G: boolean;
    };
    allowed: {
        spin180: boolean;
        hardDrop: boolean;
        hold: boolean;
    };
    infiniteHold: boolean;
    username?: string;
    date?: Date;
}
export interface EngineInitializeParams {
    queue: QueueInitializeParams;
    board: BoardInitializeParams;
    kickTable: KickTable;
    options: GameOptions;
    gravity: IncreasableValue;
    garbage: GarbageQueueInitializeParams;
    handling: Game.Handling;
    pc: PCOptions;
    b2b: B2BOptions;
    multiplayer?: MultiplayerOptions;
    misc: MiscellaneousOptions;
}
export declare class Engine {
    #private;
    queue: Queue;
    held: Mino | null;
    holdLocked: boolean;
    falling: Tetromino;
    private _kickTable;
    board: Board;
    connectedBoard: ConnectedBoard;
    lastSpin: {
        piece: Mino;
        type: SpinType;
    } | null;
    lastWasClear: boolean;
    stats: {
        garbage: {
            sent: number;
            attack: number;
            receive: number;
            cleared: number;
        };
        combo: number;
        b2b: number;
        pieces: number;
        lines: number;
    };
    gameOptions: GameOptions;
    garbageQueue: GarbageQueue | LegacyGarbageQueue;
    frame: number;
    subframe: number;
    initializer: EngineInitializeParams;
    handling: Game.Handling;
    input: {
        lShift: {
            held: boolean;
            arr: number;
            das: number;
            dir: -1;
        };
        rShift: {
            held: boolean;
            arr: number;
            das: number;
            dir: 1;
        };
        lastShift: number;
        keys: {
            [k in "softDrop" | "rotateCCW" | "rotateCW" | "rotate180" | "hold"]: boolean;
        };
        firstInputTime: number;
        time: {
            start: number;
            zero: boolean;
            locked: boolean;
            prev: number;
            frameoffset: number;
        };
        lastPieceTime: number;
    };
    pc: PCOptions;
    b2b: B2BOptions;
    dynamic: {
        gravity: IncreaseTracker;
        garbageMultiplier: IncreaseTracker;
        garbageCap: IncreaseTracker;
    };
    glock: number;
    multiplayer?: {
        options: MultiplayerOptions;
        targets: number[];
        passthrough: {
            network: boolean;
            replay: boolean;
            travel: boolean;
        };
    };
    igeHandler: IGEHandler;
    misc: MiscellaneousOptions;
    state: number;
    currentSpike: number;
    events: EventEmitter<Events>;
    private resCache;
    constructor(options: EngineInitializeParams);
    init(): void;
    private flushRes;
    reset(): void;
    bindAll(): void;
    snapshot(): EngineSnapshot;
    fromSnapshot(snapshot: EngineSnapshot): void;
    get kickTable(): (typeof kicks)[KickTableName];
    get kickTableName(): KickTableName;
    set kickTable(value: KickTableName);
    get dynamicStats(): {
        apm: number;
        pps: number;
        vs: number;
        surgePower: number;
    };
    nextPiece(ignoreBlockout?: boolean, isHold?: boolean): void;
    initiatePiece(piece: Mino, ignoreBlockout?: boolean, isHold?: boolean): void;
    hold(_ihs?: boolean, ignoreBlockout?: boolean): boolean;
    get toppedOut(): boolean;
    rotateCW(): boolean;
    rotateCCW(): boolean;
    rotate180(): boolean;
    moveRight(): boolean;
    moveLeft(): boolean;
    dasRight(): boolean;
    dasLeft(): boolean;
    softDrop(): boolean;
    /** */
    hardDrop(): LockRes;
    press<T extends Game.Key | "dasLeft" | "dasRight">(key: T): boolean | LockRes;
    tick(frames: Game.Replay.Frame[]): {
        pieces: number;
        garbage: {
            sent: number[];
            received: OutgoingGarbage[];
        };
        keys: Game.Key[];
        lastLock: number;
    };
    receiveGarbage(...garbage: IncomingGarbage[]): void;
    getPreview(piece: Mino): {
        w: number;
        h: number;
        data: [number, number, number][];
    };
    connect(blocks: [x: number, y: number][]): (readonly [number, number, number])[];
    getConnectedPreview(piece: Mino): {
        data: (readonly [number, number, number])[];
        w: number;
        h: number;
    };
    /** @deprecated Engine.onQueuePieces is deprecated and no longer functional. Switch to Engine.events.on("queue.add", (pieces) => {}) instead. */
    onQueuePieces(_listener: (pieces: Mino[]) => void): void;
    private static colorMap;
    get text(): string;
    /** Return an engine with the same config. Does not preserve state. */
    clone(): Engine;
}
export * from "./queue";
export * from "./garbage";
export * from "./utils";
export * from "./board";
export * from "./types";
export * from "./multiplayer";
//# sourceMappingURL=index.d.ts.map