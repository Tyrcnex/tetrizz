"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Board", {
    enumerable: true,
    get: function() {
        return Board;
    }
});
const _types = require("../queue/types");
_export_star(require("./connected"), exports);
function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
        if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
            Object.defineProperty(to, k, {
                enumerable: true,
                get: function() {
                    return from[k];
                }
            });
        }
    });
    return from;
}
class Board {
    state;
    _height;
    _width;
    _buffer;
    constructor(options){
        this._width = options.width;
        this._height = options.height;
        this._buffer = options.buffer;
        this.state = Array(this.fullHeight).fill(null).map(()=>Array(this.width).fill(null));
    }
    get height() {
        return this._height;
    }
    set height(value) {
        this._height = value;
    }
    get width() {
        return this._width;
    }
    set width(value) {
        this._width = value;
    }
    get buffer() {
        return this._buffer;
    }
    set buffer(value) {
        this._buffer = value;
    }
    get fullHeight() {
        return this.height + this.buffer;
    }
    occupied(x, y) {
        return x < 0 || y < 0 || x >= this.width || y >= this.fullHeight || this.state[y][x] !== null;
    }
    add(...blocks) {
        blocks.forEach(([char, x, y])=>{
            if (y < 0 || y >= this.fullHeight || x < 0 || x >= this.width) return;
            this.state[y][x] = char;
        });
    }
    clearLines() {
        let garbageCleared = 0;
        const lines = [];
        this.state.forEach((row, idx)=>{
            if (row.every((block)=>block !== null && block !== _types.Mino.BOMB)) {
                lines.push(idx);
                if (row.some((block)=>block === _types.Mino.GARBAGE)) garbageCleared++;
            }
        });
        [
            ...lines
        ].reverse().forEach((line)=>{
            this.state.splice(line, 1);
            this.state.push(new Array(this.width).fill(null));
        });
        return {
            lines: lines.length,
            garbageCleared
        };
    }
    clearBombs(placedBlocks) {
        let lowestY = placedBlocks.reduce((acc, [_, y])=>Math.min(acc, y), this.fullHeight);
        if (lowestY === 0) return {
            lines: 0,
            garbageCleared: 0
        };
        const lowestBlocks = placedBlocks.filter(([_, y])=>y === lowestY);
        const bombColumns = lowestBlocks.filter(([x, y])=>this.state[y - 1][x] === _types.Mino.BOMB).map(([x, _])=>x);
        if (bombColumns.length === 0) return {
            lines: 0,
            garbageCleared: 0
        };
        const lines = [];
        while(lowestY > 0 && bombColumns.some((col)=>this.state[lowestY - 1][col] === _types.Mino.BOMB)){
            lines.push(--lowestY);
        }
        if (lines.length === 0) return {
            lines: 0,
            garbageCleared: 0
        };
        lines.forEach((line)=>{
            this.state.splice(line, 1);
            this.state.push(new Array(this.width).fill(null));
        });
        return {
            lines: lines.length,
            garbageCleared: lines.length
        };
    }
    clearBombsAndLines(placedBlocks) {
        const bombs = this.clearBombs(placedBlocks);
        const lines = this.clearLines();
        return {
            lines: lines.lines + bombs.lines,
            garbageCleared: bombs.garbageCleared + lines.garbageCleared
        };
    }
    get perfectClear() {
        return this.state.every((row)=>row.every((block)=>block === null));
    }
    insertGarbage({ amount, size, column, bombs }) {
        this.state.splice(0, 0, ...Array.from({
            length: amount
        }, ()=>Array.from({
                length: this.width
            }, (_, idx)=>idx >= column && idx < column + size ? bombs ? _types.Mino.BOMB : null : _types.Mino.GARBAGE)));
        this.state.splice(this.fullHeight - amount - 1, amount);
    }
}

//# sourceMappingURL=index.js.map