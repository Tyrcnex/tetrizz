import { EventEmitter } from "..";
import type { Engine, Mino } from "../../engine";
import { Adapter } from "./core";
import type * as Messages from "./types/messages";
import { type ChildProcessWithoutNullStreams } from "child_process";
export interface AdapterIOConfig {
    /** The name of the adapter. Used when logging to the terminal. */
    name: string;
    /** Whether to log all messages and non-json output to the terminal */
    verbose: boolean;
    /** The path to the binary executable. */
    path: string;
    /**
     * The environment variables to set for the child process.
     * For example, when using rust, you might set RUST_BACKTRACE=1
     */
    env: NodeJS.ProcessEnv;
    /** Any additional command-line arguments to pass tothe executable */
    args: string[];
}
/**
 * Communicates with a binary engine executable using Standard Input/Output.
 * Uses JSON messages.
 * @see {@link Messages.CustomMessageData}
 */
export declare class AdapterIO<T extends Messages.CustomMessageData> extends Adapter<T> {
    #private;
    static defaultConfig: Omit<AdapterIOConfig, "path">;
    log(msg: string, { force, level }?: {
        force: boolean;
        level: "info" | "warning" | "error";
    }): void;
    cfg: AdapterIOConfig;
    events: EventEmitter<Messages.Incoming.EventMap<T>>;
    dead: boolean;
    process: ChildProcessWithoutNullStreams;
    constructor(config: Partial<AdapterIOConfig> & {
        path: string;
    });
    initialize(): Promise<Messages.Incoming.Info<T>>;
    send(message: Messages.Outgoing.all<T>): void;
    config(engine: Engine, data?: T["config"]): void;
    update(engine: Engine, data?: T["state"]): void;
    addPieces(pieces: Mino[], data?: T["pieces"]): void;
    play(engine: Engine, data?: T["play"]): Promise<Messages.Incoming.Move<T>>;
    stop(): void;
}
//# sourceMappingURL=adapter-io.d.ts.map