"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "basic", {
    enumerable: true,
    get: function() {
        return basic;
    }
});
const _ = require("..");
const _promises = /*#__PURE__*/ _interop_require_default(require("node:fs/promises"));
const _nodeos = /*#__PURE__*/ _interop_require_default(require("node:os"));
const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const basic = (defaults)=>{
    return {
        get: async ({ token, uri, headers = {}, json = false })=>{
            let res;
            try {
                res = await fetch(`https://tetr.io/api/${uri}`, {
                    headers: {
                        Accept: json ? "application/json" : "application/vnd.osk.theorypack",
                        "User-Agent": defaults.userAgent,
                        cookie: `${defaults.turnstile ? "cf_clearance=" + defaults.turnstile : ""}`,
                        Authorization: token === null ? undefined : `Bearer ${token || defaults.token}`,
                        ...headers
                    }
                });
            } catch (err) {
                throw new Error(`Fetch failed on GET to ${uri}: ${err.message || err}`);
            }
            const copy = res.clone();
            try {
                return json ? await res.json() : _.pack.unpack(Buffer.from(await res.arrayBuffer()));
            } catch  {
                if (res.status === 429) throw new Error(`Rate limit (429) on GET to ${uri}`);
                else {
                    try {
                        await _promises.default.readdir(_nodepath.default.join(_nodeos.default.homedir(), ".trianglejs", "errors"));
                    } catch  {
                        await _promises.default.mkdir(_nodepath.default.join(_nodeos.default.homedir(), ".trianglejs", "errors"), {
                            recursive: true
                        });
                    }
                    const now = Date.now();
                    const text = await copy.text();
                    await _promises.default.writeFile(_nodepath.default.join(_nodeos.default.homedir(), ".trianglejs", "errors", `${now}.html`), text);
                    if (copy.status === 404) throw new Error(`404 on GET to ${uri}`);
                    if (text.includes("<title>Server error</title>")) throw new Error(`The TETR.IO Servers are currently unavailable. Check https://status.osk.sh for updates. You can view more information at ${_nodepath.default.join(_nodeos.default.homedir(), ".trianglejs", "errors", `${now}.html`)}`);
                    if (text.includes("<title>Maintenance</title>")) throw new Error(`The TETR.IO Servers are under maintanence. Check https://status.osk.sh for updates. You can view more information at ${_nodepath.default.join(_nodeos.default.homedir(), ".trianglejs", "errors", `${now}.html`)}`);
                    else throw new Error(`An error occured. This was likely because it the request was blocked by Cloudflare Turnstile on GET to ${uri}. Try passing in a turnstile token. View the error at ${_nodepath.default.join(_nodeos.default.homedir(), ".trianglejs", "errors", `${now}.html`)}`);
                }
            }
        },
        post: async ({ token, uri, body, headers = {}, json = false })=>{
            let res;
            try {
                res = await fetch(`https://tetr.io/api/${uri}`, {
                    method: "POST",
                    //@ts-ignore
                    body: json ? JSON.stringify(body) : _.pack.pack(body),
                    headers: {
                        Accept: json ? "application/json" : "application/vnd.osk.theorypack",
                        "User-Agent": defaults.userAgent,
                        cookie: `${defaults.turnstile ? "cf_clearance=" + defaults.turnstile : ""}`,
                        "Content-Type": json ? "application/json" : "application/vnd.osk.theorypack",
                        Authorization: token === null ? undefined : `Bearer ${token || defaults.token}`,
                        ...headers
                    }
                });
            } catch (err) {
                throw new Error(`Fetch failed on POST to ${uri}: ${err.message || err}`);
            }
            const copy = res.clone();
            try {
                return json ? await res.json() : _.pack.unpack(Buffer.from(await res.arrayBuffer()));
            } catch  {
                if (res.status === 429) throw new Error(`Rate limit (429) on GET to ${uri}`);
                else {
                    try {
                        await _promises.default.readdir(_nodepath.default.join(_nodeos.default.homedir(), ".trianglejs", "errors"));
                    } catch  {
                        await _promises.default.mkdir(_nodepath.default.join(_nodeos.default.homedir(), ".trianglejs", "errors"), {
                            recursive: true
                        });
                    }
                    const now = Date.now();
                    const text = await copy.text();
                    await _promises.default.writeFile(_nodepath.default.join(_nodeos.default.homedir(), ".trianglejs", "errors", `${now}.html`), text);
                    console.log(text);
                    if (copy.status === 404) throw new Error(`404 on POST to ${uri}`);
                    if (text.includes("<title>Maintenance</title>")) throw new Error(`The TETR.IO Servers are under maintanence. Check https://status.osk.sh for updates. You can view more information at ${_nodepath.default.join(_nodeos.default.homedir(), ".trianglejs", "errors", `${now}.html`)}`);
                    else throw new Error(`An error occured. This was likely because the request was blocked by Cloudflare Turnstile on GET to ${uri}. Try passing in a turnstile token. View the error at ${_nodepath.default.join(_nodeos.default.homedir(), ".trianglejs", "errors", `${now}.html`)}`);
                }
            }
        }
    };
};

//# sourceMappingURL=basic.js.map