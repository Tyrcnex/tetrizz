{"version":3,"sources":["../../../../src/types/events/in/client.ts"],"sourcesContent":["import type { Game, Room } from \"../..\";\nimport type { Relationship, Room as RoomClass } from \"../../../classes\";\nimport type { Engine } from \"../../../engine\";\nimport type { Social } from \"../../social\";\nimport type { Game as GameEvents } from \"./game\";\nimport type { Ribbon } from \"./ribbon\";\n\nexport type Hex = `#${string}`;\n\nexport interface Client {\n  /** Fires inside Client.create(), will never fire afterwards. */\n  \"client.ready\": {\n    endpoint: string;\n    social: Ribbon[\"server.authorize\"][\"social\"];\n  };\n  /** Fires when recieving an \"err\" notification. Data is the \"msg\" of the notification */\n  \"client.error\": string;\n  /** Fires when the client dies. */\n  \"client.dead\": string;\n  /**\n   * Fires when the websocket closes.\n   * Note: the websocket might just be migrating, to check for a fully disconnected client, use `client.dead`\n   */\n  \"client.close\": string;\n\n  /** Any notification popup */\n  \"client.notify\": {\n    msg: string;\n    timeout?: number;\n    subcolor?: Hex;\n    fcolor?: Hex;\n    color?: Hex;\n    bgcolor?: Hex;\n    icon?: string;\n    subicon?: string;\n    header?: string;\n    classes?: string;\n    buttons?: { icon?: string; label: string; classes?: string }[];\n    id?: string;\n  };\n\n  /** Fires whenever the players state changes. */\n  \"client.room.players\": Room.Player[];\n\n  /** Fires when the client joins a room */\n  \"client.room.join\": RoomClass;\n\n  /** Fires when a game starts */\n  \"client.game.start\": { multi: boolean; ft: number; wb: number } & {\n    players: { id: string; name: string; points: 0 }[];\n  };\n\n  /** Fires when a round starts (this includes 1-round games) */\n  \"client.game.round.start\": [\n    (cb: Game.Tick.Func) => void,\n    Engine,\n    { name: string; gameid: number; engine: Engine }[]\n  ];\n  /** Fires when the client's game ends (topout). Finish = game.replay.end, abort = game.abort, end = game.end or game.advance or game.score */\n  \"client.game.over\":\n    | {\n        reason: \"finish\";\n        data: GameEvents[\"game.replay.end\"][\"data\"];\n      }\n    | {\n        reason: \"abort\";\n      }\n    | {\n        reason: \"end\";\n      }\n    | {\n        reason: \"leave\";\n      };\n  /** Fires when a round is over, sends the user id of the winning player, if there is one. */\n  \"client.game.round.end\": string | null;\n  /**\n   * Fires when a game ends. Likely known issue:\n   * @see https://github.com/tetrjs/tetr.js/issues/62\n   */\n  \"client.game.end\": {\n    duration: number;\n    players: {\n      id: string;\n      name: string;\n      points: number;\n      won: boolean;\n      raw: Game.Leaderboard;\n    }[];\n  };\n\n  /** Same as game.abort */\n  \"client.game.abort\": void;\n\n  /** Fires when a message is recived from the server. Contains the raw data of the server message. Useful for logging, do not use for handling events for functionality. Instead, use `client.on(<event>)`. */\n  \"client.ribbon.receive\": { command: string; data?: any };\n\n  /** Fires when a message is sent to the server. Contains the raw data of the server message. Useful for logging. */\n  \"client.ribbon.send\": { command: string; data?: any };\n\n  /** Fires whenever a Ribbon log is outputted */\n  \"client.ribbon.log\": string;\n  /** Fires whenever a Ribbon warning is outputted*/\n  \"client.ribbon.warn\": string;\n  /** Fires whenever Ribbon encounters an error */\n  \"client.ribbon.error\": string;\n\n  // relationship stuff\n  /** Fires whenever the client is friended */\n  \"client.friended\": { id: string; name: string; avatar: number };\n\n  /** Fires when a DM (direct message) has been received and AFTER any unknown data has been loaded about the user */\n  \"client.dm\": {\n    user: Relationship;\n    content: string;\n    reply: (message: string) => Promise<Social.DM>;\n  };\n}\n"],"names":[],"mappings":"AASA,WA2GC"}