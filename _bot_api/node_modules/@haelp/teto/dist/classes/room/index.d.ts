import type { Events, Game as GameTypes, Room as RoomTypes, Utils } from "../../types";
import { Client } from "../client";
import { ReplayManager } from "./replayManager";
export declare class Room {
    private client;
    private listeners;
    /** the ID of the room */
    id: string;
    /** Whether or not the room is public */
    public: boolean;
    /** The type of the room (public | private) */
    type: RoomTypes.Type;
    /** Name of the room */
    name: string;
    /** Safe Name of the room */
    name_safe: string;
    /** UID of the host */
    owner: string;
    /** UID of the room creator (this person can reclaim host) */
    creator: string;
    /** The autostart state of the room */
    autostart: RoomTypes.Autostart;
    /** The match config for the room */
    match: RoomTypes.Match;
    /** The maxiumum number of players that can play in the room (override by moving as host) */
    userLimit: number;
    /** The players in the room */
    players: RoomTypes.Player[];
    /** The room config */
    options: GameTypes.Options;
    /** The current state of the room (ingame | lobby) */
    state: RoomTypes.State;
    /** The time the last game started */
    gameStart: number | null;
    /** The replay data for the last played game */
    replay: ReplayManager | null;
    /** Room chat history */
    chats: Events.in.Room["room.chat"][];
    /** @hideconstructor */
    constructor(client: Client, data: Events.in.Room["room.update"]);
    private handleUpdate;
    private listen;
    private init;
    /** Whether or not the client is the host */
    get isHost(): boolean;
    private destroy;
    /**
     * Leave the current room
     * @example
     * await client.room!.leave();
     */
    leave(): Promise<void>;
    /**
     * Kick a user from the room for a specified duration (if host)
     * @param id - id of user to kick
     * @param duration - duration to kick the user, in seconds
     * @example
     * await client.room!.kick('646f633d276f42a80ba44304', 100);
     */
    kick(id: string, duration?: number): Promise<string>;
    /**
     * Unban a user from the room
     * @example
     * client.room!.unban('halp');
     */
    unban(username: string): void;
    /**
     * Send a public message to the room's chat.
     * The `pinned` parameter is the same as using the `/announce` command in TETR.IO
     * The `pinned` parameter being true will result in an error if the client is not host.
     * @example
     * await client.room!.chat('hi!');
     * @example
     * await client.room!.chat('Important info:', true);
     */
    chat(message: string, pinned?: boolean): Promise<{
        content: string;
        content_safe: string;
        user: {
            username: string;
            _id: string;
            role: import("../../types").User.Role;
            supporter: boolean;
            supporter_tier: number;
            verified: boolean;
        };
        pinned: boolean;
        system: boolean;
    }>;
    /**
     * Clears the chat
     */
    clearChat(): Promise<void>;
    /**
     * Sets the room id (only works for supporter accounts)
     * @example
     * client.room!.setID('TEST');
     */
    setID(id: string): Promise<{
        id: string;
        public: boolean;
        name: string;
        name_safe: string;
        type: RoomTypes.Type;
        owner: string;
        creator: string;
        state: RoomTypes.State;
        topic: {};
        info: {};
        auto: RoomTypes.Autostart;
        options: GameTypes.Options;
        match: 
        /** Name of the room */
        RoomTypes.Match;
        players: RoomTypes.Player[];
    }>;
    /**
     * Update the room's config, similar to using the /set command in tetr.io
     * await client.room!.update({ index: 'name', value: 'test room'});
     * @returns
     */
    update<T extends Utils.DeepKeys<RoomTypes.SetConfig>>(...options: {
        index: T;
        value: Utils.DeepKeyValue<RoomTypes.SetConfig, T>;
    }[]): Promise<{
        id: string;
        public: boolean;
        name: string;
        name_safe: string;
        type: RoomTypes.Type;
        owner: string;
        creator: string;
        state: RoomTypes.State;
        topic: {};
        info: {};
        auto: RoomTypes.Autostart;
        options: GameTypes.Options;
        match: 
        /** Name of the room */
        RoomTypes.Match;
        players: RoomTypes.Player[];
    }>;
    /**
     * Sets the room's preset
     * @example
     * await client.room!.usePreset('tetra league (season 1)');
     */
    usePreset(preset: GameTypes.Preset): Promise<{
        id: string;
        public: boolean;
        name: string;
        name_safe: string;
        type: RoomTypes.Type;
        owner: string;
        creator: string;
        state: RoomTypes.State;
        topic: {};
        info: {};
        auto: RoomTypes.Autostart;
        options: GameTypes.Options;
        match: 
        /** Name of the room */
        RoomTypes.Match;
        players: RoomTypes.Player[];
    }>;
    /**
     * Start the game
     */
    start(): Promise<GameTypes.Ready>;
    /**
     * Abort the game
     */
    abort(): Promise<void>;
    /**
     * Give the host to someone else
     * @example
     * await client.room!.transferHost(await client.social.resolve('halp'));
     */
    transferHost(player: string): Promise<string>;
    /** Take host if you created the room */
    takeHost(): Promise<string>;
    /**
     * Switch bracket
     * @example
     * await client.room!.switch('player');
     */
    switch(bracket: "player" | "spectator"): Promise<{
        uid: string;
        bracket: RoomTypes.Bracket;
    } | undefined>;
    /**
     * Move someone's bracket
     * @example
     * await client.room!.move('646f633d276f42a80ba44304', 'spectator');
     */
    move(uid: string, bracket: "player" | "spectator"): Promise<{
        uid: string;
        bracket: RoomTypes.Bracket;
    } | undefined>;
}
export { ReplayManager } from "./replayManager";
//# sourceMappingURL=index.d.ts.map