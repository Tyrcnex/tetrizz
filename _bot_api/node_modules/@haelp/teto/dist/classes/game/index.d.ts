import { Engine } from "../../engine";
import type { Game as GameTypes } from "../../types";
import type { BotWrapper } from "../../utils/bot-wrapper";
import { Client } from "../client";
export declare class Game {
    #private;
    private client;
    private listeners;
    private frameQueue;
    private incomingGarbage;
    private timeout;
    private messageQueue;
    private startTime;
    private tick?;
    private isPractice;
    /** The client's engine */
    engine: Engine;
    /** Data on all players in game, including the client */
    players: {
        name: string;
        gameid: number;
        userid: string;
        engine: Engine;
        queue: GameTypes.Replay.Frame[];
    }[];
    get opponents(): {
        name: string;
        gameid: number;
        userid: string;
        engine: Engine;
        queue: GameTypes.Replay.Frame[];
    }[];
    /** The client's `gameid` set by the server */
    gameid: number;
    /** The raw game config sent by TETR.IO */
    options: GameTypes.ReadyOptions;
    /** The raw game config for all players, including the client's own game config */
    readyData: GameTypes.Ready;
    /** The targets set by the server */
    serverTargets: number[];
    /** The gameids of the users targeting the client */
    enemies: number[];
    /** The keys the client has queued to press (allows for pressing keys in the future) */
    keyQueue: NonNullable<GameTypes.Tick.Out["keys"]>;
    /** Whether or not targeting is allowed (changed by server). Setting target while this is `false` will throw an error. */
    canTarget: boolean;
    /** Whether or not the client's game is over (topped out), and no longer ticking. */
    over: boolean;
    /** The BotWrapper in use. When a BotWrapper is set, `tick` will not be called. */
    botWrapper?: BotWrapper;
    /** The last time IGEs were flushed */
    lastIGEFlush: number;
    /** The Frames Per Second of the TETR.IO engine */
    static fps: number;
    /** The maximum amount of time before all IGEs are force-flushed */
    static maxIGETimeout: number;
    /** Frames per message */
    private static fpm;
    /** @hideconstructor */
    constructor(client: Client, ready: GameTypes.Ready);
    private listen;
    /** Kill the game. This is called automatically by the Room class when a game ends/is aborted, you don't need to use this. */
    destroy(): undefined;
    /**
     * Stops the client's gameplay, when it dies. Does not destroy the game.
     */
    stop(): void;
    private init;
    private start;
    createEngine(options: GameTypes.ReadyOptions, gameid: number): Engine;
    private flushFrames;
    private tickGame;
    /**
     * Send raw frames to TETR.IO -
     * Not recommended for normal use.
     */
    pipe(...frames: GameTypes.Replay.Frame[]): void;
    /**
     * The current targeting strategy. Setting a targeting strategy throws error if targeting is not allowed.
     */
    get target(): GameTypes.Target;
    set target(t: GameTypes.Target);
    /**
     * The game's current frame
     */
    get frame(): number;
    private set frame(value);
    /** Pauses accepting IGEs (garbage events) when the `keyQueue` has items, when `pauseIGEs` is set to true. */
    get pauseIGEs(): boolean;
    set pauseIGEs(value: boolean);
    /** Force stops the processing of all IGEs (garbage, etc). If left `true` for too long (~30s), IGEs will be automatically flushed to avoid a forced disconnect. Use sparingly. */
    get forcePauseIGEs(): boolean;
    set forcePauseIGEs(value: boolean);
    /** Whether or not the `Game` is currently allowed to process IGEs. */
    get igesPaused(): boolean;
}
//# sourceMappingURL=index.d.ts.map